# lab3
Задание 1
Программа выделяет память с помощью `new` в бесконечном цикле и не освобождает её, что приводит к утечке памяти.
`createMemoryLeak()` создаёт массив `int` внутри цикла, но не вызывает `delete[]`.  
Показал, как ручное управление может привести к утечкам памяти.

Задание 2
Переписал программу из задания 1 с использованием `std::unique_ptr`, который сам освобождает ресурсы. Также создал класс `File`, использующий RAII для автоматического закрытия файла.
`useUniquePtr` выделяет массив с `std::unique_ptr<int[]>`.
`FileManager` открывает файл в конструкторе и закрывает в деструкторе.
Продемонстрировал автоматическое управление ресурсами через RAII и `unique_ptr`.

Задание 3
Реализовал сценарий, где несколько объектов совместно используют один и тот же ресурс.
Cоздается `std::shared_ptr` и копируется.
Выводится значение счётчика ссылок через `.use_count()`.
Показал, как `shared_ptr` управляет временем жизни объекта через счётчик ссылок.

Задание 4
Наблюдение за объектом, которым владеет `shared_ptr`, без продления его времени жизни.
Observer хранит `std::weak_ptr<Subject>`, поэтому не влияет на время жизни `Subject`.
С помощью `.lock()` мы преобразуем `weak_ptr` в `shared_ptr`, если объект еще жив.
После `.reset()` `Subject` удаляется, и наблюдатель узнает, что объект уничтожен.


Умные указатели (std::unique_ptr, std::shared_ptr, std::weak_ptr) реализуют RAII (Resource Acquisition Is Initialization) — объект освобождает ресурсы в своём деструкторе, автоматически.
std::unique_ptr — это умный указатель, который обладает уникальным правом владения объектом. Это означает, что в каждый момент времени только один unique_ptr может владеть конкретным ресурсом. При уничтожении unique_ptr автоматически освобождает занимаемую память. Копирование unique_ptr запрещено, возможна только передача владения через перемещение. Это делает его самым лёгким и безопасным по производительности вариантом. Рекомендуется использовать unique_ptr по умолчанию, когда не требуется совместное владение.

std::shared_ptr — это умный указатель, реализующий совместное владение. Несколько shared_ptr могут указывать на один и тот же объект. При этом ведётся счётчик ссылок: объект удаляется только тогда, когда последний shared_ptr, ссылающийся на него, уничтожается или переназначается. shared_ptr удобно использовать, когда объект должен существовать, пока он нужен нескольким частям программы. Однако за счёт счётчика ссылок он медленнее и требует большей осторожности.

std::weak_ptr — это вспомогательный указатель, который не владеет объектом, а только ссылается на объект, управляемый shared_ptr. Он не увеличивает счётчик ссылок и позволяет избежать циклических зависимостей между shared_ptr, при которых память не освобождается. Чтобы использовать объект, на который ссылается weak_ptr, необходимо сначала проверить его существование с помощью метода lock().

unique_ptr — используется по умолчанию. Если объекту нужен только один владелец — это лучший выбор.

shared_ptr — применяется, если объект должен жить до тех пор, пока он нужен нескольким объектам.

weak_ptr — используется вместе с shared_ptr, чтобы разорвать циклические зависимости, например в графах или деревьях.
